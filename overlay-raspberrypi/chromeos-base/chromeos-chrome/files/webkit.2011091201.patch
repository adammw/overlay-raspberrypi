diff --git third_party/WebKit/Source/WebCore/WebCore.gypi third_party/WebKit/Source/WebCore/WebCore.gypi
index 28b75be..7827988 100644
--- third_party/WebKit/Source/WebCore/WebCore.gypi
+++ third_party/WebKit/Source/WebCore/WebCore.gypi
@@ -2247,6 +2247,7 @@
             'bridge/c/c_utility.cpp',
             'bridge/c/c_utility.h',
             'bridge/jni/JNIUtility.cpp',
+            'bridge/jni/JavaString.h',
             'bridge/jni/JavaType.h',
             'bridge/jni/JobjectWrapper.cpp',
             'bridge/jni/JobjectWrapper.h',
@@ -3209,6 +3210,8 @@
             'platform/chromium/DataTransferItemChromium.h',
             'platform/chromium/DataTransferItemsChromium.cpp',
             'platform/chromium/DataTransferItemsChromium.h',
+            'platform/chromium/DoubleTapGestureChromium.cpp',
+            'platform/chromium/DoubleTapGestureChromium.h',
             'platform/chromium/DragDataChromium.cpp',
             'platform/chromium/DragDataRef.h',
             'platform/chromium/DragImageChromiumMac.cpp',
@@ -3218,6 +3221,10 @@
             'platform/chromium/FileSystemChromiumLinux.cpp',
             'platform/chromium/FileSystemChromiumMac.mm',
             'platform/chromium/FileSystemChromiumWin.cpp',
+            'platform/chromium/FlickAnimator.cpp',
+            'platform/chromium/FlickAnimator.h',
+            'platform/chromium/FlickGestureChromium.cpp',
+            'platform/chromium/FlickGestureChromium.h',
             'platform/chromium/FramelessScrollView.cpp',
             'platform/chromium/FramelessScrollView.h',
             'platform/chromium/FramelessScrollViewClient.h',
diff --git third_party/WebKit/Source/WebCore/page/EventHandler.cpp third_party/WebKit/Source/WebCore/page/EventHandler.cpp
index 4e467ea..502bade 100644
--- third_party/WebKit/Source/WebCore/page/EventHandler.cpp
+++ third_party/WebKit/Source/WebCore/page/EventHandler.cpp
@@ -2203,10 +2203,7 @@ void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent* wheelEv
 #if ENABLE(GESTURE_EVENTS)
 bool EventHandler::handleGestureEvent(const PlatformGestureEvent& gestureEvent)
 {
-    // FIXME: This should hit test and go to the correct subframe rather than 
-    // always sending gestures to the main frame only. We should also ensure
-    // that if a frame gets a gesture begin gesture, it gets the corresponding
-    // end gesture as well.
+    Document* doc = m_frame->document();
 
     switch (gestureEvent.type()) {
     case PlatformGestureEvent::TapDownType:
@@ -2221,26 +2218,99 @@ bool EventHandler::handleGestureEvent(const PlatformGestureEvent& gestureEvent)
         handleMouseReleaseEvent(fakeMouseUp);
         return true;
     }
-    case PlatformGestureEvent::DoubleTapType:
-        break;
     case PlatformGestureEvent::ScrollUpdateType: {
-        const float tickDivisor = (float)WheelEvent::tickMultiplier;
-        // FIXME: Replace this interim implementation once the above fixme has been addressed.
-        IntPoint point(gestureEvent.position().x(), gestureEvent.position().y());
-        IntPoint globalPoint(gestureEvent.globalPosition().x(), gestureEvent.globalPosition().y());
-        PlatformWheelEvent syntheticWheelEvent(point, globalPoint, gestureEvent.deltaX(), gestureEvent.deltaY(), gestureEvent.deltaX() / tickDivisor, gestureEvent.deltaY() / tickDivisor, ScrollByPixelWheelEvent, /* isAccepted */ false, gestureEvent.shiftKey(), gestureEvent.ctrlKey(), gestureEvent.altKey(), gestureEvent.metaKey());
-        handleWheelEvent(syntheticWheelEvent);
+        // If there is only one reference, it's ours and someone else has deleted the target
+        // since the ScrollBeginType so skip delivering the event and free the reference.
+        if (m_gestureEventWidgetTarget.get() && m_gestureEventWidgetTarget->refCount() > 1 && passGestureEventToWidget(gestureEvent, m_gestureEventWidgetTarget.get()))
+            return true;
+        if (m_gestureEventWidgetTarget.get() && m_gestureEventWidgetTarget->hasOneRef())
+            m_gestureEventWidgetTarget.clear();
+
+        if (m_gestureTargetNode.get() && m_gestureTargetNode->refCount() > 1) {
+            RenderLayer* layer = ((RenderBox*)m_gestureTargetNode->renderer())->layer();
+            layer->handleGestureEvent(gestureEvent);
+        } else if (m_gestureTargetNode.get() && m_gestureTargetNode->hasOneRef())
+            m_gestureTargetNode.clear();
+
+        FrameView* view = m_frame->view();
+        if (!view)
+            return false;
+        setFrameWasScrolledByUser();
+        view->handleGestureEvent(gestureEvent);
         return true;
     }
-    case PlatformGestureEvent::ScrollBeginType:
-    case PlatformGestureEvent::ScrollEndType:
+    case PlatformGestureEvent::ScrollBeginType: {
+         FrameView* view = m_frame->view();
+         if (!view)
+             return false;
+  
+        LayoutPoint vPoint = view->windowToContents(gestureEvent.position());
+        Node* node;
+        bool isOverWidget;
+   
+        HitTestRequest request(HitTestRequest::ReadOnly);
+        HitTestResult result(vPoint);
+        doc->renderView()->layer()->hitTest(request, result);
+ 
+        view->handleGestureEvent(gestureEvent);
+        node = result.innerNode();
+        isOverWidget = result.isOverWidget();
+        
+        if (node) {
+            RenderObject* target = node->renderer();
+
+            if (isOverWidget && target && target->isWidget()) {
+                m_gestureEventWidgetTarget = toRenderWidget(target)->widget();
+                if (m_gestureEventWidgetTarget && passGestureEventToWidget(gestureEvent, m_gestureEventWidgetTarget.get()))
+                    return true;
+            }
+
+            node = node->shadowAncestorNode();
+            target = node->renderer();
+            
+            while (target && !target->isRoot()) {
+                if (target->isBox()) {
+                    RenderBox* rb = (RenderBox*)target;
+                    if (rb->canBeScrolledAndHasScrollableArea()) {
+                        m_gestureTargetNode = rb->node();
+                        rb->layer()->handleGestureEvent(gestureEvent);
+                        return true; // FIXME: Prove that this is correct.
+                    }
+                }
+                target = target->parent();
+            }
+        }
+         return true;
+    }
+    case PlatformGestureEvent::ScrollEndType: {
+        if (m_gestureEventWidgetTarget.get() && m_gestureEventWidgetTarget->refCount() > 1 && passGestureEventToWidget(gestureEvent, m_gestureEventWidgetTarget.get())) {
+            m_gestureEventWidgetTarget.clear();
+            m_gestureTargetNode.clear();
+            return true;
+         } else if (m_gestureEventWidgetTarget.get() && m_gestureEventWidgetTarget->hasOneRef())
+            m_gestureEventWidgetTarget.clear();
+
+        if (m_gestureTargetNode.get() && m_gestureTargetNode->refCount() > 1) {
+            RenderLayer* layer = ((RenderBox*)m_gestureTargetNode->renderer())->layer();
+            layer->handleGestureEvent(gestureEvent);
+            m_gestureEventWidgetTarget.clear();
+            m_gestureTargetNode.clear();
+        } else if (m_gestureTargetNode.get() && m_gestureTargetNode->hasOneRef())
+            m_gestureTargetNode.clear();
+
         FrameView* view = m_frame->view();
         if (!view)
             return false;
-
         view->handleGestureEvent(gestureEvent);
         return true;
     }
+    case PlatformGestureEvent::ZoomBeginType:
+    case PlatformGestureEvent::ZoomUpdateType:
+    case PlatformGestureEvent::ZoomEndType:
+    case PlatformGestureEvent::DoubleTapType:
+        // FIXME: Insert double tap handling here.
+        return false;
+    }
     return true;
 }
 #endif
diff --git third_party/WebKit/Source/WebCore/page/EventHandler.h third_party/WebKit/Source/WebCore/page/EventHandler.h
index cf2fe81..1ff7c7b 100644
--- third_party/WebKit/Source/WebCore/page/EventHandler.h
+++ third_party/WebKit/Source/WebCore/page/EventHandler.h
@@ -300,6 +300,9 @@ private:
 
     bool passMouseDownEventToWidget(Widget*);
     bool passWheelEventToWidget(PlatformWheelEvent&, Widget*);
+#if ENABLE(GESTURE_EVENTS)
+    bool passGestureEventToWidget(const PlatformGestureEvent&, Widget*);
+#endif
 
     void defaultSpaceEventHandler(KeyboardEvent*);
     void defaultBackspaceEventHandler(KeyboardEvent*);
@@ -421,6 +424,11 @@ private:
     TouchTargetMap m_originatingTouchPointTargets;
     bool m_touchPressed;
 #endif
+#if ENABLE(GESTURE_EVENTS)
+    RefPtr<Widget> m_gestureEventWidgetTarget;
+    RefPtr<Node> m_gestureTargetNode;
+#endif
+
 };
 
 } // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/page/brew/EventHandlerBrew.cpp third_party/WebKit/Source/WebCore/page/brew/EventHandlerBrew.cpp
index ae5d83b..c8c3276 100644
--- third_party/WebKit/Source/WebCore/page/brew/EventHandlerBrew.cpp
+++ third_party/WebKit/Source/WebCore/page/brew/EventHandlerBrew.cpp
@@ -103,6 +103,14 @@ bool EventHandler::passWheelEventToWidget(PlatformWheelEvent& event, Widget* wid
     return false;
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(PlatformGestureEvent&, Widget*)
+{
+    notImplemented();
+    return false;
+}
+#endif
+
 bool EventHandler::passMousePressEventToSubframe(MouseEventWithHitTestResults& mev, Frame* subframe)
 {
     return passSubframeEventToSubframe(mev, subframe);
diff --git third_party/WebKit/Source/WebCore/page/chromium/EventHandlerChromium.cpp third_party/WebKit/Source/WebCore/page/chromium/EventHandlerChromium.cpp
index 40a71ab..351a7f5 100644
--- third_party/WebKit/Source/WebCore/page/chromium/EventHandlerChromium.cpp
+++ third_party/WebKit/Source/WebCore/page/chromium/EventHandlerChromium.cpp
@@ -44,6 +44,11 @@
 #include "PlatformWheelEvent.h"
 #include "RenderWidget.h"
 
+#if ENABLE(GESTURE_EVENTS) || ENABLE(GESTURE_RECOGNIZER)
+#include "PlatformGestureEvent.h"
+#endif
+
+
 namespace WebCore {
 
 #if OS(DARWIN)
@@ -164,4 +169,21 @@ bool EventHandler::shouldTurnVerticalTicksIntoHorizontal(const HitTestResult& re
 }
 #endif
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(const PlatformGestureEvent& gestureEvent, Widget* widget)
+{
+    // We can sometimes get a null widget! EventHandlerMac handles a null
+    // widget by returning false, so we do the same.
+    if (!widget)
+        return false;
+
+    // If not a FrameView, then probably a plugin widget. Those will receive
+    // the event via an EventTargetNode dispatch when this returns false.
+    if (!widget->isFrameView())
+        return false;
+
+    return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleGestureEvent(gestureEvent);
+}
+#endif
+
 } // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/page/efl/EventHandlerEfl.cpp third_party/WebKit/Source/WebCore/page/efl/EventHandlerEfl.cpp
index 3a3c4dd..2b9dacc 100644
--- third_party/WebKit/Source/WebCore/page/efl/EventHandlerEfl.cpp
+++ third_party/WebKit/Source/WebCore/page/efl/EventHandlerEfl.cpp
@@ -95,6 +95,14 @@ bool EventHandler::passWheelEventToWidget(PlatformWheelEvent& event, Widget* wid
     return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleWheelEvent(event);
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(const PlatformGestureEvent&, Widget*)
+{
+    notImplemented();
+    return false;
+}
+#endif
+
 PassRefPtr<Clipboard> EventHandler::createDraggingClipboard() const
 {
     return ClipboardEfl::create(ClipboardWritable, Clipboard::DragAndDrop);
diff --git third_party/WebKit/Source/WebCore/page/gtk/EventHandlerGtk.cpp third_party/WebKit/Source/WebCore/page/gtk/EventHandlerGtk.cpp
index ab54d83..5e43abd 100644
--- third_party/WebKit/Source/WebCore/page/gtk/EventHandlerGtk.cpp
+++ third_party/WebKit/Source/WebCore/page/gtk/EventHandlerGtk.cpp
@@ -94,6 +94,14 @@ bool EventHandler::passWheelEventToWidget(PlatformWheelEvent& event, Widget* wid
     return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleWheelEvent(event);
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(PlatformGestureEvent&, Widget*)
+{
+    notImplemented();
+    return false;
+}
+#endif
+
 PassRefPtr<Clipboard> EventHandler::createDraggingClipboard() const
 {
     return ClipboardGtk::create(ClipboardWritable, DataObjectGtk::create(), Clipboard::DragAndDrop, m_frame);
diff --git third_party/WebKit/Source/WebCore/page/haiku/EventHandlerHaiku.cpp third_party/WebKit/Source/WebCore/page/haiku/EventHandlerHaiku.cpp
index 5c53614..ca9706f 100644
--- third_party/WebKit/Source/WebCore/page/haiku/EventHandlerHaiku.cpp
+++ third_party/WebKit/Source/WebCore/page/haiku/EventHandlerHaiku.cpp
@@ -137,5 +137,13 @@ unsigned EventHandler::accessKeyModifiers()
     return PlatformKeyboardEvent::AltKey;
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(PlatformGestureEvent&, Widget*)
+{
+    notImplemented();
+    return false;
+}
+#endif
+
 } // namespace WebCore
 
diff --git third_party/WebKit/Source/WebCore/page/mac/EventHandlerMac.mm third_party/WebKit/Source/WebCore/page/mac/EventHandlerMac.mm
index 736deaf..4a8c4cc 100644
--- third_party/WebKit/Source/WebCore/page/mac/EventHandlerMac.mm
+++ third_party/WebKit/Source/WebCore/page/mac/EventHandlerMac.mm
@@ -736,4 +736,25 @@ unsigned EventHandler::accessKeyModifiers()
     return PlatformKeyboardEvent::CtrlKey | PlatformKeyboardEvent::AltKey;
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passWheelEventToWidget(const PlatformGestureEvent& gestureEvent, Widget* widget)
+{
+    BEGIN_BLOCK_OBJC_EXCEPTIONS;
+
+    if (!widget)
+        return false;
+
+    NSView* nodeView = widget->platformWidget();
+    if (!nodeView) {
+        // WebKit2 code path.
+        if (!widget->isFrameView())
+            return false;
+
+        return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleWheelEvent(gestureEvent);
+    }
+    END_BLOCK_OBJC_EXCEPTIONS;
+    return false;
+}
+#endif
+
 }
diff --git third_party/WebKit/Source/WebCore/page/qt/EventHandlerQt.cpp third_party/WebKit/Source/WebCore/page/qt/EventHandlerQt.cpp
index 2b8804d4..9e8645c 100644
--- third_party/WebKit/Source/WebCore/page/qt/EventHandlerQt.cpp
+++ third_party/WebKit/Source/WebCore/page/qt/EventHandlerQt.cpp
@@ -98,6 +98,17 @@ bool EventHandler::passWheelEventToWidget(PlatformWheelEvent& event, Widget* wid
     return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleWheelEvent(event);
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(PlatformGestureEvent& event, Widget* widget)
+{
+    Q_ASSERT(widget);
+    if (!widget->isFrameView())
+        return false;
+
+    return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleGestureEvent(event);
+}
+#endif
+
 PassRefPtr<Clipboard> EventHandler::createDraggingClipboard() const
 {
     return ClipboardQt::create(ClipboardWritable, m_frame, Clipboard::DragAndDrop);
diff --git third_party/WebKit/Source/WebCore/page/win/EventHandlerWin.cpp third_party/WebKit/Source/WebCore/page/win/EventHandlerWin.cpp
index 721e350..d7a14be 100644
--- third_party/WebKit/Source/WebCore/page/win/EventHandlerWin.cpp
+++ third_party/WebKit/Source/WebCore/page/win/EventHandlerWin.cpp
@@ -81,6 +81,14 @@ bool EventHandler::passWheelEventToWidget(PlatformWheelEvent& wheelEvent, Widget
     return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleWheelEvent(wheelEvent);
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(const PlatformGestureEvent&, Widget*)
+{
+    notImplemented();
+    return false;
+}
+#endif
+
 bool EventHandler::tabsToAllFormControls(KeyboardEvent*) const
 {
     return true;
diff --git third_party/WebKit/Source/WebCore/page/wx/EventHandlerWx.cpp third_party/WebKit/Source/WebCore/page/wx/EventHandlerWx.cpp
index ba2f9cd..5fbfbcd 100644
--- third_party/WebKit/Source/WebCore/page/wx/EventHandlerWx.cpp
+++ third_party/WebKit/Source/WebCore/page/wx/EventHandlerWx.cpp
@@ -82,6 +82,14 @@ bool EventHandler::passWheelEventToWidget(PlatformWheelEvent& event, Widget* wid
     return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleWheelEvent(event);
 }
 
+#if ENABLE(GESTURE_EVENTS)
+bool EventHandler::passGestureEventToWidget(PlatformGestureEvent&, Widget*)
+{
+    notImplemented(); 
+    return false; 
+}
+#endif
+
 bool EventHandler::tabsToAllFormControls(KeyboardEvent* event) const 
 { 
     notImplemented(); 
diff --git third_party/WebKit/Source/WebCore/platform/PlatformGestureEvent.h third_party/WebKit/Source/WebCore/platform/PlatformGestureEvent.h
index 833c6a3..c945547 100644
--- third_party/WebKit/Source/WebCore/platform/PlatformGestureEvent.h
+++ third_party/WebKit/Source/WebCore/platform/PlatformGestureEvent.h
@@ -41,6 +41,9 @@ public:
         TapType,
         TapDownType,
         DoubleTapType,
+        ZoomBeginType,
+        ZoomUpdateType,
+        ZoomEndType,
     };
 
     PlatformGestureEvent()
@@ -48,7 +51,7 @@ public:
         , m_timestamp(0)
     {
     }
-
+    
     PlatformGestureEvent(Type type, const IntPoint& position, const IntPoint& globalPosition, const double timestamp, const float deltaX, const float deltaY, bool shiftKey, bool ctrlKey, bool altKey, bool metaKey)
         : m_type(type)
         , m_position(position)
diff --git third_party/WebKit/Source/WebCore/platform/ScrollAnimator.cpp third_party/WebKit/Source/WebCore/platform/ScrollAnimator.cpp
index 5538efd..b2d668a 100644
--- third_party/WebKit/Source/WebCore/platform/ScrollAnimator.cpp
+++ third_party/WebKit/Source/WebCore/platform/ScrollAnimator.cpp
@@ -32,11 +32,19 @@
 #include "ScrollAnimator.h"
 
 #include "FloatPoint.h"
+#include "PlatformGestureEvent.h"
 #include "PlatformWheelEvent.h"
 #include "ScrollableArea.h"
 #include <algorithm>
 #include <wtf/PassOwnPtr.h>
 
+#if ENABLE(GESTURE_RECOGNIZER) || ENABLE(GESTURE_EVENTS)
+#include "PlatformGestureEvent.h"
+#endif
+
+
+#include <stdio.h>
+
 using namespace std;
 
 namespace WebCore {
@@ -52,6 +60,7 @@ ScrollAnimator::ScrollAnimator(ScrollableArea* scrollableArea)
     : m_scrollableArea(scrollableArea)
     , m_currentPosX(0)
     , m_currentPosY(0)
+    , m_flicker(adoptPtr(new FlickAnimator(scrollableArea)))
 {
 }
 
@@ -114,8 +123,41 @@ void ScrollAnimator::handleWheelEvent(PlatformWheelEvent& e)
 }
 
 #if ENABLE(GESTURE_EVENTS)
-void ScrollAnimator::handleGestureEvent(const PlatformGestureEvent&)
+void ScrollAnimator::handleGestureEvent(const PlatformGestureEvent& event)
 {
+    // FIXME: finish handler here.
+    // functionality should go here.
+    switch(event.type()) {
+    case PlatformGestureEvent::ScrollBeginType:
+        // FIXME: need stupendous adjustment.a
+        fprintf(stderr, "ScrollAnimator::handleGestureEvent ScrollBeginType \n");
+        m_flicker->startFlick(event);
+        break;
+    case PlatformGestureEvent::ScrollEndType:
+        fprintf(stderr, "ScrollAnimator::handleGestureEvent ScrollEndType \n");
+        m_flicker->stopFlick();        
+        break;
+    case PlatformGestureEvent::ScrollUpdateType: {
+        IntSize maxForwardScrollDelta = m_scrollableArea->maximumScrollPosition() - m_scrollableArea->scrollPosition();
+        IntSize maxBackwardScrollDelta = m_scrollableArea->scrollPosition() - m_scrollableArea->minimumScrollPosition();
+        float deltaX = (event.deltaX() < 0.f) ? max(event.deltaX(),  -float(maxForwardScrollDelta.width())) : min(event.deltaX(), float(maxBackwardScrollDelta.width()));
+        float deltaY = (event.deltaY() < 0.f) ? max(event.deltaY(),  -float(maxForwardScrollDelta.height())) : min(event.deltaY(), float(maxBackwardScrollDelta.height()));
+
+        IntRect contentRect = m_scrollableArea->visibleContentRect(true);
+        FloatPoint offset = FloatPoint(contentRect.x() - deltaX, contentRect.y() - deltaY);
+        scrollToOffsetWithoutAnimation(offset);
+        break;
+    }
+    case PlatformGestureEvent::TapDownType:
+        m_flicker->stopFlick();
+        break;
+    case PlatformGestureEvent::TapType:
+    case PlatformGestureEvent::ZoomBeginType:
+    case PlatformGestureEvent::ZoomUpdateType:
+    case PlatformGestureEvent::ZoomEndType:
+    case PlatformGestureEvent::DoubleTapType:
+        break;    
+    }
 }
 #endif
 
diff --git third_party/WebKit/Source/WebCore/platform/ScrollAnimator.h third_party/WebKit/Source/WebCore/platform/ScrollAnimator.h
index 667381b..7683549 100644
--- third_party/WebKit/Source/WebCore/platform/ScrollAnimator.h
+++ third_party/WebKit/Source/WebCore/platform/ScrollAnimator.h
@@ -31,8 +31,10 @@
 #ifndef ScrollAnimator_h
 #define ScrollAnimator_h
 
+#include "FlickAnimator.h"
 #include "ScrollTypes.h"
 #include <wtf/Forward.h>
+#include <wtf/OwnPtr.h>
 
 namespace WebCore {
 
@@ -41,7 +43,7 @@ class PlatformWheelEvent;
 class ScrollableArea;
 class Scrollbar;
 
-#if ENABLE(GESTURE_EVENTS)
+#if ENABLE(GESTURE_RECOGNIZER) || ENABLE(GESTURE_EVENTS)
 class PlatformGestureEvent;
 #endif
 
@@ -64,7 +66,7 @@ public:
     virtual void setIsActive() { }
 
     virtual void handleWheelEvent(PlatformWheelEvent&);
-#if ENABLE(GESTURE_EVENTS)
+#if ENABLE(GESTURE_RECOGNIZER) || ENABLE(GESTURE_EVENTS)
     virtual void handleGestureEvent(const PlatformGestureEvent&);
 #endif
 
@@ -95,6 +97,8 @@ protected:
     ScrollableArea* m_scrollableArea;
     float m_currentPosX; // We avoid using a FloatPoint in order to reduce
     float m_currentPosY; // subclass code complexity.
+
+    OwnPtr<FlickAnimator> m_flicker;
 };
 
 } // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/platform/ScrollableArea.h third_party/WebKit/Source/WebCore/platform/ScrollableArea.h
index c39e15c..fcd416b 100644
--- third_party/WebKit/Source/WebCore/platform/ScrollableArea.h
+++ third_party/WebKit/Source/WebCore/platform/ScrollableArea.h
@@ -164,6 +164,7 @@ public:
 private:
     // NOTE: Only called from the ScrollAnimator.
     friend class ScrollAnimator;
+    friend class FlickAnimator;
     void setScrollOffsetFromAnimation(const IntPoint&);
 
     mutable OwnPtr<ScrollAnimator> m_scrollAnimator;
diff --git third_party/WebKit/Source/WebCore/platform/chromium/DoubleTapGestureChromium.cpp third_party/WebKit/Source/WebCore/platform/chromium/DoubleTapGestureChromium.cpp
new file mode 100644
index 0000000..eac394e
--- /dev/null
+++ third_party/WebKit/Source/WebCore/platform/chromium/DoubleTapGestureChromium.cpp
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2011, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "DoubleTapGestureChromium.h"
+
+#include "EventHandler.h"
+#include "GestureRecognizerChromium.h"
+#include "PlatformGestureEvent.h"
+#include <math.h>
+#include "PlatformWheelEvent.h"
+#include <wtf/Assertions.h>
+#include <wtf/MathExtras.h>
+
+
+namespace WebCore {
+
+static const double maximumTouchDownDurationInSecondsForClick = 0.8;
+static const double minimumTouchDownDurationInSecondsForClick = 0.01;
+static const int maximumTouchMoveInPixelsForClick = 20;
+
+DoubleTapGestureChromium::DoubleTapGestureChromium()
+    : m_lastTouchScreenPosition(IntPoint())
+    , m_lastTouchPosition(IntPoint())
+    , m_firstTouchTime(0.0)
+    , m_lastTouchTime(0.0)
+    , m_lastClickTime(0.0)
+    , m_state(NoGesture)
+{
+}
+
+void DoubleTapGestureChromium::reset()
+{
+    m_lastTouchScreenPosition = IntPoint();
+    m_lastTouchPosition = IntPoint();
+    m_firstTouchTime = 0.0;
+    m_lastTouchTime = 0.0;
+    m_lastClickTime = 0.0;
+    m_state = NoGesture;
+    GestureRecognizerChromiumDelegate::reset();
+}
+
+DoubleTapGestureChromium::~DoubleTapGestureChromium()
+{
+}
+
+void DoubleTapGestureChromium::updateValues(const double touchTime, const PlatformTouchPoint& touchPoint)
+{
+    if (m_state == FirstTapReceived) {
+        m_lastClickTime = m_lastTouchTime;
+        m_lastClickPosition = m_lastTouchPosition;
+    }
+
+    if (m_state == NoGesture || m_state == FirstTapReceived) {
+        m_firstTouchTime = touchTime;
+        m_firstTouchPosition = touchPoint.pos();
+    }
+    m_lastTouchTime = touchTime;
+    m_lastTouchPosition = touchPoint.pos();
+    m_lastTouchScreenPosition = touchPoint.screenPos();
+}
+
+PlatformGestureRecognizer::PassGestures DoubleTapGestureChromium::processTouchEventForGestures(const PlatformTouchEvent& event, bool handled, PlatformGestureRecognizer::PassGestures existingGestures)
+{
+    OwnPtr<Vector<PlatformGestureEvent> > gestures(existingGestures);
+    const Vector<PlatformTouchPoint>& points = event.touchPoints();
+    for (unsigned i = 0; i < points.size(); i++) {
+        const PlatformTouchPoint& p = points[i];
+        updateValues(event.timestamp(), p);
+        if (m_state == NoGesture && p.state() == PlatformTouchPoint::TouchPressed) {
+            m_state = PendingFirstTap;
+            handled = false;
+        } else if (m_state == PendingFirstTap) {
+            if (detectTap(p))
+                m_state = FirstTapReceived;
+            handled = false;
+        } else if (m_state == FirstTapReceived) {
+            ASSERT(p.state() == PlatformTouchPoint::TouchPressed);
+            if (isSecondClickInTimeWindow() && isSecondClickInsideManhattanSquare(p))
+                m_state = PendingDoubleTap;
+            else
+                m_state = PendingFirstTap;
+            handled = false;
+        } else if (m_state == PendingDoubleTap) {
+            if (detectTap(p)) {
+                fprintf(stderr, ">>>>>DOUBLE TAP DETECTED\n");
+                m_state = NoGesture;
+                gestures->append(PlatformGestureEvent(PlatformGestureEvent::DoubleTapType, p.pos(), p.screenPos(), m_lastClickTime, /* deltaX */ 0.f, /* deltaY */ 0.f, /* fshiftKey */ false, /* ctrlKey */ false, /* altKey */ false, /* metaKey */ false));
+            }
+            handled = true;
+        }
+     }
+    return GestureRecognizerChromiumDelegate::processTouchEventForGestures(event, handled, gestures.release());
+}
+
+bool DoubleTapGestureChromium::detectTap(const PlatformTouchPoint& tp)
+{
+    switch(tp.state()) {
+        case PlatformTouchPoint::TouchCancelled:
+            reset();
+            return false;
+        case PlatformTouchPoint::TouchReleased:
+            if (isInClickTimeWindow() && isInsideManhattanSquare(tp))
+                return true;
+            m_state = NoGesture;
+            return false;
+        case PlatformTouchPoint::TouchMoved:
+        case PlatformTouchPoint::TouchStationary:
+            if (!isInsideManhattanSquare(tp))
+                m_state = NoGesture;
+            return false;
+        default:
+            fprintf(stderr, ">>>>>WTF: %d\n", tp.state());
+            ASSERT_NOT_REACHED();
+    }
+    return false;
+}
+
+bool DoubleTapGestureChromium::isInClickTimeWindow()
+{
+    double duration(m_lastTouchTime - m_firstTouchTime);
+    return duration >= minimumTouchDownDurationInSecondsForClick && duration < maximumTouchDownDurationInSecondsForClick;
+}
+
+bool DoubleTapGestureChromium::isInsideManhattanSquare(const PlatformTouchPoint& point)
+{
+    int manhattanDistance = abs(point.pos().x() - m_firstTouchPosition.x()) + abs(point.pos().y() - m_firstTouchPosition.y());
+    return manhattanDistance < maximumTouchMoveInPixelsForClick;
+}
+
+bool DoubleTapGestureChromium::isSecondClickInTimeWindow()
+{
+    double duration(m_firstTouchTime - m_lastClickTime);
+    return duration >= minimumTouchDownDurationInSecondsForClick && duration < maximumTouchDownDurationInSecondsForClick;
+}
+
+bool DoubleTapGestureChromium::isSecondClickInsideManhattanSquare(const PlatformTouchPoint& point)
+{
+    int manhattanDistance = abs(point.pos().x() - m_lastClickPosition.x()) + abs(point.pos().y() - m_lastClickPosition.y());
+    return manhattanDistance < maximumTouchMoveInPixelsForClick;
+}
+} // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/platform/chromium/DoubleTapGestureChromium.h third_party/WebKit/Source/WebCore/platform/chromium/DoubleTapGestureChromium.h
new file mode 100644
index 0000000..58ae544
--- /dev/null
+++ third_party/WebKit/Source/WebCore/platform/chromium/DoubleTapGestureChromium.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2011, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+  This file is not to be upstreamed. This file contains additional gestures that
+  are not in the upstreamable gesture manager. The point here is (largely) to
+  discern what we need to do in order to make the GestureRecognizer fully
+  extensible.
+
+  I have left this file in Source/WebCore/platform/chromium for convenience.
+  It shouldn't require being here. It shouldn't depend on anything.
+
+*/
+
+#ifndef DoubleTapGestureChromium_h
+#define DoubleTapGestureChromium_h
+
+#include "GestureRecognizerChromium.h"
+#include "PlatformGestureRecognizer.h"
+#include "PlatformTouchEvent.h"
+#include "Timer.h"
+#include "TouchEvent.h"
+#include <wtf/HashMap.h>
+
+namespace WebCore {
+
+class DoubleTapGestureChromium : public GestureRecognizerChromiumDelegate {
+public:
+    enum State {
+        NoGesture,
+        PendingFirstTap,
+        FirstTapReceived,
+        PendingDoubleTap,
+    };
+
+    DoubleTapGestureChromium();
+    virtual ~DoubleTapGestureChromium();
+
+    static PassRefPtr<GestureRecognizerChromiumDelegate> create();
+    virtual PlatformGestureRecognizer::PassGestures processTouchEventForGestures(const PlatformTouchEvent&, bool handled, PlatformGestureRecognizer::PassGestures);
+    virtual void reset();
+
+private:
+    bool detectTap(const PlatformTouchPoint&);
+    bool isInClickTimeWindow();
+    bool isInsideManhattanSquare(const PlatformTouchPoint& point);
+    bool isSecondClickInTimeWindow();
+    bool isSecondClickInsideManhattanSquare(const PlatformTouchPoint& point);
+    void updateValues(const double, const PlatformTouchPoint&);
+
+    IntPoint m_lastTouchScreenPosition;
+    IntPoint m_lastTouchPosition;
+    IntPoint m_firstTouchPosition;
+    double m_firstTouchTime;
+    double m_lastTouchTime;
+    double m_lastClickTime;
+    IntPoint m_lastClickPosition;
+
+    State m_state;
+};
+
+
+} // namespace WebCore
+
+#endif // DoubleTapGestureChromium_h
diff --git third_party/WebKit/Source/WebCore/platform/chromium/FlickAnimator.cpp third_party/WebKit/Source/WebCore/platform/chromium/FlickAnimator.cpp
new file mode 100644
index 0000000..c7eca31
--- /dev/null
+++ third_party/WebKit/Source/WebCore/platform/chromium/FlickAnimator.cpp
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2011, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "FlickAnimator.h"
+
+#include "DoubleTapGestureChromium.h"
+#include "GestureRecognizerChromium.h"
+#include <math.h>
+#include "PlatformGestureEvent.h"
+#include "ScrollableArea.h"
+#include <wtf/Assertions.h>
+#include <wtf/MathExtras.h>
+
+
+namespace WebCore {
+
+static const double frictionPerTimeStamp = .98;
+static const double autoScrollTimeStep = 0.0166;
+static const float initialActualScrollVelocity = 10000.0;
+static const float minimumScrollVelocity = 4.f;
+
+FlickAnimator::FlickAnimator(ScrollableArea* scrollableArea)
+    : m_scrollingTimer(this, &FlickAnimator::scrollingTimerFired)
+    , m_lastTouchPosition(FloatPoint())
+    , m_lastTouchTime(0.0)
+    , m_xVelocity(0.0f)
+    , m_yVelocity(0.0f)
+    , m_scrollableArea(scrollableArea)
+{
+}
+
+void FlickAnimator::reset()
+{
+    m_scrollingTimer.stop();
+    m_lastTouchPosition = FloatPoint();
+    m_lastTouchTime = 0.0;
+    m_xVelocity = 0.0f;
+    m_yVelocity = 0.0f;
+}
+
+FlickAnimator::~FlickAnimator()
+{
+}
+
+void FlickAnimator::startFlick(const PlatformGestureEvent& event) {
+    fprintf(stderr, "FlickAnimator::startFlick...\n");
+
+    if (m_scrollingTimer.isActive())
+        return;
+    
+    IntRect contentRect = m_scrollableArea->visibleContentRect(true);
+    m_lastTouchPosition = FloatPoint(contentRect.x() + event.position().x(), contentRect.y() + event.position().y());
+    fprintf(stderr, "scrollingTimerFired startFlick, m_lastTouchPosition: %f, %f\n", m_lastTouchPosition.x(), m_lastTouchPosition.y());
+    m_xVelocity = event.deltaX();
+    m_yVelocity = event.deltaY();
+    
+    // Bound the velocity.
+    float sign = signbit(m_xVelocity) ? -1.0 : 1.0;
+    m_xVelocity = sign * WTF::min(initialActualScrollVelocity, fabsf(3.f * m_xVelocity));
+    
+    sign = signbit(m_yVelocity) ? -1.0 : 1.0;
+    m_yVelocity = sign * WTF::min(initialActualScrollVelocity, fabsf(3.f * m_yVelocity));
+    
+
+    // fire once now
+    scrollingTimerFired(&m_scrollingTimer);
+    
+    // and keep firing every autoScrollTimeStep
+    m_scrollingTimer.startRepeating(autoScrollTimeStep);
+}
+
+void FlickAnimator::stopFlick() {
+    fprintf(stderr, "FlickAnimator::stopFlick...\n");
+    if (m_scrollingTimer.isActive()) {
+        m_scrollingTimer.stop();
+        reset();
+    }      
+}
+
+void FlickAnimator::scrollingTimerFired(Timer<FlickAnimator>* t) {
+    // FIXME: stop the timer if no more motion is possible.
+    // FIXME: bound the speed...
+    fprintf(stderr, "timer fired, velo: %f, %f\n", m_xVelocity, m_yVelocity);
+
+    float deltaX(m_xVelocity * autoScrollTimeStep);
+    float deltaY(m_yVelocity * autoScrollTimeStep);
+
+    // fprintf(stderr, "timer fired, deltas: %f, %f\n", deltaX, deltaY);
+    m_scrollableArea->scrollToOffsetWithoutAnimation( m_lastTouchPosition );
+
+    // Do I need this...
+    m_lastTouchPosition = FloatPoint(m_lastTouchPosition.x() - deltaX, m_lastTouchPosition.y() - deltaY);
+    // m_lastTouchScreenPosition = IntPoint(m_lastTouchScreenPosition.x() - deltaX, m_lastTouchScreenPosition.y() - deltaY);
+
+    // frictionPerTimeStamp must be < 1.
+    m_xVelocity *= frictionPerTimeStamp;
+    m_yVelocity *= frictionPerTimeStamp;
+
+    if (fabsf(deltaX) < minimumScrollVelocity) {
+        m_xVelocity = 0.0;
+    }
+    if (fabsf(deltaY) < minimumScrollVelocity) {
+        m_yVelocity = 0.0;
+    }
+    if (fabsf(deltaX) < minimumScrollVelocity && fabsf(deltaY) < minimumScrollVelocity) {
+        fprintf(stderr, "shutting timer down, velo: \n");
+        m_scrollingTimer.stop();
+    }
+    fprintf(stderr, "timer done, velo: \n");
+}
+
+} // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/platform/chromium/FlickAnimator.h third_party/WebKit/Source/WebCore/platform/chromium/FlickAnimator.h
new file mode 100644
index 0000000..6985254
--- /dev/null
+++ third_party/WebKit/Source/WebCore/platform/chromium/FlickAnimator.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2011, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FlickAnimator_h
+#define FlickAnimator_h
+ 
+#include "Timer.h"
+#include "FloatPoint.h"
+#include "TouchEvent.h"
+#include <wtf/HashMap.h>
+
+namespace WebCore {
+
+class PlatformGestureEvent;
+class ScrollableArea;
+
+class FlickAnimator {
+public:
+    FlickAnimator(ScrollableArea*);
+    ~FlickAnimator();
+    void reset();
+    void stopFlick();
+    void startFlick(const PlatformGestureEvent&);
+    
+private:
+    void scrollingTimerFired(Timer<FlickAnimator>*);
+    Timer<FlickAnimator> m_scrollingTimer;
+
+    // IntPoint m_lastTouchScreenPosition;
+    FloatPoint m_lastTouchPosition;
+    double m_lastTouchTime;
+    float m_xVelocity;
+    float m_yVelocity;
+    
+    ScrollableArea* m_scrollableArea;
+};
+
+
+} // namespace WebCore
+
+#endif // FlickAnimator_h
diff --git third_party/WebKit/Source/WebCore/platform/chromium/FlickGestureChromium.cpp third_party/WebKit/Source/WebCore/platform/chromium/FlickGestureChromium.cpp
new file mode 100644
index 0000000..6fbbcf0
--- /dev/null
+++ third_party/WebKit/Source/WebCore/platform/chromium/FlickGestureChromium.cpp
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2011, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "FlickGestureChromium.h"
+
+#include "DoubleTapGestureChromium.h"
+#include "GestureRecognizerChromium.h"
+#include <math.h>
+#include "PlatformGestureEvent.h"
+#include "PlatformWheelEvent.h"
+#include <wtf/Assertions.h>
+#include <wtf/MathExtras.h>
+
+
+namespace WebCore {
+
+static const float minFlickSpeed = 1000.0;
+static const double frictionPerTimeStamp = .98;
+static const double autoScrollTimeStep = 0.0166;
+static const float initialActualScrollVelocity = 3000.0;
+
+FlickGestureChromium::FlickGestureChromium()
+    : m_lastTouchScreenPosition(IntPoint())
+    , m_lastTouchPosition(IntPoint())
+    , m_lastTouchTime(0.0)
+    , m_xVelocity(0.0f)
+    , m_yVelocity(0.0f)
+    , m_state(NoGesture)
+{
+}
+
+void FlickGestureChromium::reset()
+{
+    m_lastTouchScreenPosition = IntPoint();
+    m_lastTouchPosition = IntPoint();
+    m_lastTouchTime = 0.0;
+    m_xVelocity = 0.0f;
+    m_yVelocity = 0.0f;
+    m_state = NoGesture;
+    GestureRecognizerChromiumDelegate::reset();
+}
+
+FlickGestureChromium::~FlickGestureChromium()
+{
+}
+
+bool FlickGestureChromium::isOverMinFlickSpeed() {
+    return sqrt(m_xVelocity * m_xVelocity + m_yVelocity * m_yVelocity) > minFlickSpeed;
+}
+
+void FlickGestureChromium::updateValues(const double touchTime, const PlatformTouchPoint& touchPoint)
+{
+    if (m_state == NoGesture && touchPoint.state() == PlatformTouchPoint::TouchPressed) {
+        m_lastTouchTime = touchTime;
+        m_lastTouchPosition = touchPoint.pos();
+        m_lastTouchScreenPosition = touchPoint.screenPos();
+        m_xVelocity = 0.0;
+        m_yVelocity = 0.0;
+    } else  if (touchPoint.state() == PlatformTouchPoint::TouchMoved) {
+        double interval(touchTime - m_lastTouchTime);
+         m_xVelocity = (touchPoint.pos().x() - m_lastTouchPosition.x()) / interval;
+         m_yVelocity = (touchPoint.pos().y() - m_lastTouchPosition.y()) / interval;
+        m_lastTouchPosition = touchPoint.pos();
+        m_lastTouchScreenPosition = touchPoint.screenPos();
+        m_lastTouchTime = touchTime;
+    }
+}
+
+PlatformGestureRecognizer::PassGestures FlickGestureChromium::processTouchEventForGestures(const PlatformTouchEvent& event, bool handled, PlatformGestureRecognizer::PassGestures existingGestures)
+{
+    OwnPtr<Vector<PlatformGestureEvent> > gestures(existingGestures);
+
+    const Vector<PlatformTouchPoint>& points = event.touchPoints();
+    for (unsigned i = 0; i < points.size(); i++) {
+        const PlatformTouchPoint& p = points[i];
+        updateValues(event.timestamp(), p);
+        if (m_state == NoGesture && isOverMinFlickSpeed() && p.state() == PlatformTouchPoint::TouchReleased) {
+            // fprintf(stderr, ">>>>>> dispatching flick start\n");
+            gestures->append(PlatformGestureEvent(PlatformGestureEvent::ScrollBeginType, p.pos(), p.screenPos(), m_lastTouchTime, m_xVelocity, m_yVelocity, false, false, false, false));
+            
+            m_state = Flick;
+            handled = true;
+        } else if (m_state == Flick && p.state() == PlatformTouchPoint::TouchPressed) {
+            m_state = NoGesture;
+            // fprintf(stderr, ">>>>>> dispatching flick end\n");
+            gestures->append(PlatformGestureEvent(PlatformGestureEvent::ScrollEndType, p.pos(), p.screenPos(), m_lastTouchTime, 0.0f, 0.0f, false, false, false, false));
+            reset();
+        }
+     }
+    return GestureRecognizerChromiumDelegate::processTouchEventForGestures(event, handled, gestures.release());;
+}
+
+// Replaces the one from somewhere else.
+PassOwnPtr<PlatformGestureRecognizer> PlatformGestureRecognizer::create()
+{
+    GestureRecognizerChromium* gestureRecognizer = new GestureRecognizerChromium();
+    FlickGestureChromium* flickGesture = new FlickGestureChromium();
+    gestureRecognizer->setDelegate(adoptRef(flickGesture));
+    gestureRecognizer->setDelegate(adoptRef(new DoubleTapGestureChromium()));
+
+    return adoptPtr(gestureRecognizer);
+}
+
+} // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/platform/chromium/FlickGestureChromium.h third_party/WebKit/Source/WebCore/platform/chromium/FlickGestureChromium.h
new file mode 100644
index 0000000..03d558f
--- /dev/null
+++ third_party/WebKit/Source/WebCore/platform/chromium/FlickGestureChromium.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2011, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+  This file is not to be upstreamed. This file contains additional gestures that
+  are not in the upstreamable gesture manager. The point here is (largely) to
+  discern what we need to do in order to make the GestureRecognizer fully
+  extensible.
+  
+  I have left this file in Source/WebCore/platform/chromium for convenience.
+  It shouldn't require being here. It shouldn't depend on anything. 
+
+*/
+
+#ifndef ExternalGesturesChromium_h
+#define ExternalGesturesChromium_h
+ 
+#include "GestureRecognizerChromium.h"
+#include "PlatformGestureRecognizer.h"
+#include "PlatformTouchEvent.h"
+#include "Timer.h"
+#include "TouchEvent.h"
+#include <wtf/HashMap.h>
+
+namespace WebCore {
+
+class FlickGestureChromium : public GestureRecognizerChromiumDelegate {
+public:
+    enum State {
+    NoGesture,
+    Flick
+    };
+
+    FlickGestureChromium();
+    virtual ~FlickGestureChromium();
+
+    static PassRefPtr<GestureRecognizerChromiumDelegate> create();
+    virtual PlatformGestureRecognizer::PassGestures processTouchEventForGestures(const PlatformTouchEvent&, bool handled,PlatformGestureRecognizer::PassGestures);
+    virtual void reset();
+
+private:
+    bool isOverMinFlickSpeed();
+    void scrollCore(const IntPoint& pos, const IntPoint& screenPos, float deltaX, float detaY);
+    void updateValues(const double, const PlatformTouchPoint&);
+
+    IntPoint m_lastTouchScreenPosition;
+    IntPoint m_lastTouchPosition;
+    double m_lastTouchTime;
+    float m_xVelocity;
+    float m_yVelocity;
+
+    State m_state;
+};
+
+
+} // namespace WebCore
+
+#endif // ExternalGesturesChromium_h
diff --git third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.cpp third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.cpp
index 7ab9d4b..8e5f92e 100644
--- third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.cpp
+++ third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.cpp
@@ -38,6 +38,40 @@ static const double maximumTouchDownDurationInSecondsForClick = 0.8;
 static const double minimumTouchDownDurationInSecondsForClick = 0.01;
 static const int maximumTouchMoveInPixelsForClick = 20;
 
+GestureRecognizerChromiumDelegate::GestureRecognizerChromiumDelegate()
+    : m_delegate(0)
+{
+}
+
+GestureRecognizerChromiumDelegate::~GestureRecognizerChromiumDelegate()
+{
+}
+
+
+PassRefPtr<GestureRecognizerChromiumDelegate> GestureRecognizerChromiumDelegate::create()
+{
+    return PassRefPtr<GestureRecognizerChromiumDelegate>();
+}
+
+PlatformGestureRecognizer::PassGestures GestureRecognizerChromiumDelegate::processTouchEventForGestures(const PlatformTouchEvent& touchEvent, bool handled, PlatformGestureRecognizer::PassGestures gestures)
+{
+    if (m_delegate.get())
+        return m_delegate->processTouchEventForGestures(touchEvent, handled, gestures);
+    else
+        return gestures;
+}
+
+void GestureRecognizerChromiumDelegate::reset()
+{
+    if (m_delegate.get())
+        return m_delegate->reset();
+}
+
+void GestureRecognizerChromiumDelegate::setDelegate(PassRefPtr<GestureRecognizerChromiumDelegate> delegate)
+{
+    m_delegate = delegate;
+}
+
 GestureRecognizerChromium::GestureRecognizerChromium()
     : m_firstTouchTime(0.0)
     , m_state(GestureRecognizerChromium::NoGesture)
@@ -46,6 +80,7 @@ GestureRecognizerChromium::GestureRecognizerChromium()
     , m_altKey(false)
     , m_shiftKey(false)
     , m_metaKey(false)
+    , m_delegate(0)
 {
     const unsigned FirstFinger = 0;
     const PlatformTouchPoint::State Released = PlatformTouchPoint::TouchReleased;
@@ -135,9 +170,20 @@ PlatformGestureRecognizer::PassGestures GestureRecognizerChromium::processTouchE
         if (GestureTransitionFunction ef = m_edgeFunctions.get(signature(m_state, p.id(), p.state(), defaultPrevented)))
             ((*this).*ef)(p, gestures.get());
     }
+
+    if (m_delegate.get())
+        return m_delegate->processTouchEventForGestures(event, defaultPrevented, gestures.release());
+
     return gestures.release();
 }
 
+void GestureRecognizerChromium::setDelegate(PassRefPtr<GestureRecognizerChromiumDelegate> delegate)
+{
+    if (m_delegate.get())
+        delegate->setDelegate(m_delegate);
+    m_delegate = delegate;
+}
+
 void GestureRecognizerChromium::appendScrollGestureBegin(const PlatformTouchPoint& touchPoint, Gestures gestures)
 {
     gestures->append(PlatformGestureEvent(PlatformGestureEvent::ScrollBeginType, touchPoint.pos(), touchPoint.screenPos(), m_lastTouchTime, 0.f, 0.f, m_shiftKey, m_ctrlKey, m_altKey, m_metaKey));
@@ -259,11 +305,13 @@ bool GestureRecognizerChromium::inScroll(const PlatformTouchPoint& point, Gestur
     return true;
 }
 
+#if 0
 PassOwnPtr<PlatformGestureRecognizer> PlatformGestureRecognizer::create()
 {
     GestureRecognizerChromium* gestureRecognizer = new GestureRecognizerChromium();
     return adoptPtr(gestureRecognizer);
 }
+#endif
 
 PlatformGestureRecognizer::PlatformGestureRecognizer()
 {
diff --git third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.h third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.h
index 4edda3b..0de01ab 100644
--- third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.h
+++ third_party/WebKit/Source/WebCore/platform/chromium/GestureRecognizerChromium.h
@@ -35,6 +35,7 @@
 
 #include "PlatformTouchEvent.h"
 #include "PlatformTouchPoint.h"
+#include "RefCounted.h"
 #include <wtf/HashMap.h>
 
 class InspectableGestureRecognizerChromium;
@@ -43,6 +44,20 @@ namespace WebCore {
 
 class PlatformGestureEvent;
 
+class GestureRecognizerChromiumDelegate : public RefCounted<GestureRecognizerChromiumDelegate> {
+public:
+    GestureRecognizerChromiumDelegate();
+    virtual ~GestureRecognizerChromiumDelegate();
+
+    static PassRefPtr<GestureRecognizerChromiumDelegate> create();
+    virtual PlatformGestureRecognizer::PassGestures  processTouchEventForGestures(const PlatformTouchEvent&, bool defaultPrevented, PlatformGestureRecognizer::PassGestures);
+    virtual void reset();
+    void setDelegate(PassRefPtr<GestureRecognizerChromiumDelegate>);
+
+private:
+    RefPtr<GestureRecognizerChromiumDelegate> m_delegate;
+};
+
 class GestureRecognizerChromium : public PlatformGestureRecognizer  {
 public:
     enum State {
@@ -62,6 +77,7 @@ public:
     virtual void reset();
     virtual PlatformGestureRecognizer::PassGestures  processTouchEventForGestures(const PlatformTouchEvent&, bool defaultPrevented);
     State state() { return m_state; }
+    void setDelegate(PassRefPtr<GestureRecognizerChromiumDelegate>);
 
 private:
     friend class ::InspectableGestureRecognizerChromium;
@@ -102,6 +118,7 @@ private:
     bool m_altKey;
     bool m_shiftKey;
     bool m_metaKey;
+    RefPtr<GestureRecognizerChromiumDelegate> m_delegate;
 };
 
 } // namespace WebCore
diff --git third_party/WebKit/Source/WebCore/platform/chromium/PopupContainer.cpp third_party/WebKit/Source/WebCore/platform/chromium/PopupContainer.cpp
index 73deed3..d92b287 100644
--- third_party/WebKit/Source/WebCore/platform/chromium/PopupContainer.cpp
+++ third_party/WebKit/Source/WebCore/platform/chromium/PopupContainer.cpp
@@ -316,6 +316,9 @@ bool PopupContainer::handleGestureEvent(const PlatformGestureEvent& gestureEvent
     case PlatformGestureEvent::ScrollBeginType:
     case PlatformGestureEvent::ScrollEndType:
     case PlatformGestureEvent::TapDownType:
+    case PlatformGestureEvent::ZoomBeginType:
+    case PlatformGestureEvent::ZoomUpdateType:
+    case PlatformGestureEvent::ZoomEndType:
         break;
     }
     return false;
